# ES5补充

## callback && callback()的含义

```js
callback && callback()
```

含义是：如果callback存在，则执行callback()函数。

这个 callback 通常作为函数的参数使用。举例：


```javascript
function foo(callback) {
    {
        // do something 
    }
    callback && callback() // 不传 callback 参数，则不会执行 callback() 函数 
}

foo(); // 只执行do something中的代码 
foo(callback);//callback是另一个函数，将此函数传入 foo，将会执行callback() 
```

## 前言

面试问题：

- 说一下对变量提升的理解

- 说明this的几种不同的使用场景

- 创建10个`<a>`标签，点击的时候弹出来对应的序号

- 如何理解作用域

- 实际开发中闭包的应用

涉及到的知识点：

- 执行上下文
- this
- 作用域
- 作用域链
- 闭包

# 执行上下文

执行上下文主要有两种情况：

- 全局代码： 一段`<script>`标签里，有一个全局的执行上下文。所做的事情是：变量定义、函数声明

- 函数代码：每个函数里有一个上下文。所做的事情是：变量定义、函数声明、this、arguments

PS：注意“函数声明”和“函数表达式”的区别。

## 全局执行上下文

在执行全局代码前将window确定为全局执行上下文。


（1）对全局数据进行预处理：（并没有赋值）

- var定义的全局变量==>undefined, 添加为window的属性

- function声明的全局函数==>赋值(fun), 添加为window的方法

- this==>赋值(window)

（2）开始执行全局代码



## 函数执行上下文

在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)。


（1）对局部数据进行预处理：

- 形参变量==>赋值(实参)==>添加为执行上下文的属性

- arguments==>赋值(实参列表), 添加为执行上下文的属性

- var定义的局部变量==>undefined, 添加为执行上下文的属性

- function声明的函数 ==>赋值(fun), 添加为执行上下文的方法

- this==>赋值(调用函数的对象)

（2）开始执行函数体代码



## 执行上下文栈

- 1.在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
- 2.在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
- 3.在函数执行上下文创建后, 将其添加到栈中(压栈)
- 4.在当前函数执行完后,将栈顶的对象移除(出栈)
- 5.当所有的代码执行完后, 栈中只剩下window

# this

this指的是，**调用函数的那个对象**。this永远指向函数运行时所在的对象。

解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this。

根据函数的调用方式的不同，this会指向不同的对象：【重要】

- 1.以函数的形式调用时，this永远都是window。比如`fun();`相当于`window.fun();`

- 2.以方法的形式调用时，this是调用方法的那个对象

- 3.以构造函数的形式调用时，this是新创建的那个对象

- 4.使用call和apply调用时，this是指定的那个对象

需要特别提醒的是：this的指向在函数定义时无法确认，只有函数执行时才能确定。

this的几种场景：

- 1、作为构造函数执行
- 2、作为对象的属性执行
- 3、作为普通函数执行
- 4、call apply bind



# 作用域

作用域指一个变量的**作用范围**。它是静态的(相对于上下文对象), 在编写代码时就确定了。

作用：隔离变量，不同作用域下同名变量不会有冲突。

作用域的分类：


- 全局作用域
- 函数作用域
- 没有块级作用域(ES6有了)

## 全局作用域

直接编写在script标签中的JS代码，都在全局作用域。

在全局作用域中：

- 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。


- 创建的变量都会作为window对象的属性保存。

- 创建的函数都会作为window对象的方法保存。

全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问到。

### **变量的声明提前：**（变量提升）

使用var关键字声明的变量（ 比如 `var a = 1`），**会在所有的代码执行之前被声明**（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写`a = 1`），则变量不会被声明提前。

### **函数的声明提前：**

- 使用`函数声明`的形式创建的函数`function foo(){}`，**会被声明提前**。

也就是说，它会在所有的代码执行之前就被创建，所以我们可以在函数声明之前，调用函数。

- 使用`函数表达式`创建的函数`var foo = function(){}`，**不会被声明提前**，所以不能在声明前调用。

很好理解，因为此时foo被声明了，且为undefined，并没有给其赋值`function(){}`。

## 函数作用域

**调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁。**

每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。

在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。


在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用`window.a`）

**提醒1：**

在函数作用域也有声明提前的特性：

- 使用var关键字声明的变量，是在函数作用域内有效，而且会在函数中所有的代码执行之前被声明

- 函数声明也会在函数中所有的代码执行之前执行

因此，在函数中，没有var声明的变量都会成为**全局变量**，而且并不会提前声明。

# 作用域与执行上下文的区别

区别1：

- 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时

- 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建

- 函数执行上下文是在调用函数时, 函数体代码执行之前创建

区别2：

- 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化

- 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放

联系：

  * 执行上下文(对象)是从属于所在的作用域

  * 全局上下文环境==>全局作用域

  * 函数上下文环境==>对应的函数使用域

# 作用域链


当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（**就近原则**）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错ReferenceError。

外部函数定义的变量可以被内部函数所使用，反之则不行。

理解：

- 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
- 查找变量时就是沿着作用域链来查找的

# 闭包

闭包就是能够读取其他函数内部数据（变量/函数）的函数。

只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。

## 如何产生闭包？

**当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量或函数时, 就产生了闭包。**

## 闭包到底是什么?


> 使用chrome调试查看


- 理解一: 闭包是嵌套的内部函数(绝大部分人)

- 理解二: 包含被引用变量 or 函数的对象(极少数人)

注意: 闭包存在于嵌套的内部函数中。


## 产生闭包的条件

- 1.函数嵌套

- 2.内部函数引用了外部函数的数据(变量/函数)。

- 还有一个条件是**外部函数被调用，内部函数被声明**。

  ```js
  function fn1() {
      var a = 2;
      var b = 'abc';
      function fn2() {
          //fn2内部函数被提前声明，就会产生闭包(不用调用内部函数)
          console.log(a);
      }
  }
  fn1();
  function fn3() {
      var a = 3;
      var fun4 = function () {
          //fun4采用的是“函数表达式”创建的函数，此时内部函数的声明并没有提前
          console.log(a);
      };
  }
  fn3();
  ```

## 闭包的作用

```js
//作用1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
//作用2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
function fn1() {
    var a = 2;
    function fn2() {
        a++;
        console.log(a);
    }
    return fn2;
}
var f = fn1(); //执行外部函数fn1，返回的是内部函数fn2
f(); // 3       //执行fn2
f(); // 4       //再次执行fn2
```

- 作用1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
  - **作用1分析**：外部函数fn1执行完毕后，变量a并没有立即消失，而是保存在内存当中。
- 作用2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
  - **作用2分析：**函数fn1中的变量a，是在fn1这个函数作用域内，因此外部无法访问。但是通过闭包，外部就可以操作到变量a。达到的效果是：**外界看不到变量a，但可以操作a**。比如上面达到的效果是：我看不到变量a，但是每次执行函数后，让a加1。当然，如果我真想看到a，我可以在fn2中将a返回即可。

## 回答几个问题：

- 问题1. 函数执行完后, 函数内部声明的局部变量是否还存在?

答案：一般是不存在, 存在于闭包中的变量才可能存在。

闭包能够一直存在的根本原因是`f`，因为`f`接收了`fn1()`，这个是闭包，闭包里有a。注意，此时，fn2并不存在了，但是里面的对象（即闭包）依然存在，因为用`f`接收了。


- 问题2. 在函数外部能直接访问函数内部的局部变量吗?

不能，但我们可以通过闭包让外部操作它。

## 闭包的生命周期

1. 产生: 嵌套内部函数fn2被声明时就产生了(不是在调用)

2. 死亡: 嵌套的内部函数成为垃圾对象时。（比如f = null，就可以让f成为垃圾对象。意思是，此时f不再引用闭包这个对象了）

# 常见的闭包

## 1. 将一个函数作为另一个函数的返回值

```js
function fn1() {
    var a = 2;

    function fn2() {
        a++;
        console.log(a);
    }
    return fn2;
}

var f = fn1(); //执行外部函数fn1，返回的是内部函数fn2
f(); // 3       //执行fn2
f(); // 4       //再次执行fn2
```

当f()第二次执行的时候，a加1了，也就说明了：闭包里的数据没有消失，而是保存在了内存中。如果没有闭包，代码执行完倒数第三行后，变量a就消失了。

上面的代码中，虽然调用了内部函数两次，但是，闭包对象只创建了一个。

也就是说，要看闭包对象创建了一个，就看：**外部函数执行了几次**（与内部函数执行几次无关）。

## 2. 将函数作为实参传递给另一个函数调用。

```js
function showDelay(msg, time) {
    setTimeout(function () {
        //这个function是闭包，因为是嵌套的子函数，而且引用了外部函数的变量msg
        alert(msg);
    }, time);
}
showDelay('playlife', 2000);
```

  上面的代码中，闭包是里面的funciton，因为它是嵌套的子函数，而且引用了外部函数的变量msg。

# 闭包的应用：定义具有特定功能的js模块

- 将所有的数据和功能都封装在一个函数内部(私有的)，只向外暴露一个包含n个方法的对象或函数。
- 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能。

## **方式一**

（1）myModule.js：（定义一个模块，向外暴露多个函数，供外界调用）

```js
function myModule() {
    //私有数据
    var msg = 'playlife Johnny';

    //操作私有数据的函数
    function doSomething() {
        console.log('doSomething() ' + msg.toUpperCase()); //字符串大写
    }

    function doOtherthing() {
        console.log('doOtherthing() ' + msg.toLowerCase()); //字符串小写
    }

    //通过【对象字面量】的形式进行包裹，向外暴露多个函数
    return {
        doSomething1: doSomething,
        doOtherthing2: doOtherthing,
    };
}
//上方代码中，外界可以通过doSomething1和doOtherthing2来操作里面的数据，但不让外界看到。
```

（2）index.html:

```html
<!--
闭包的应用 : 定义JS模块
  * 具有特定功能的js文件
  * 将所有的数据和功能都封装在一个函数内部(私有的)
  * 【重要】只向外暴露一个包含n个方法的对象或函数
  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
-->
<script type="text/javascript" src="myModule.js"></script>
<script type="text/javascript">
    var module = myModule();
    module.doSomething1();
    module.doOtherthing2();
</script>
```

## **方式二**

> 实现方式一功能的另一种方式

（1）myModule2.js：（是一个立即执行的匿名函数）

```js
(function () {
    //私有数据
    var msg = 'Smyhvae Haha';
    //操作私有数据的函数
    function doSomething() {
        console.log('doSomething() ' + msg.toUpperCase());
    }
    function doOtherthing() {
        console.log('doOtherthing() ' + msg.toLowerCase());
    }
    //外部函数是即使运行的匿名函数，我们可以把两个方法直接传给window对象
    window.myModule = {
        doSomething1: doSomething,
        doOtherthing2: doOtherthing,
    };
})();
```

（2）index.html：

```html
<body>
<!--
闭包的应用2 : 定义JS模块
  * 具有特定功能的js文件
  * 将所有的数据和功能都封装在一个函数内部(私有的)
  * 只向外暴露一个包信n个方法的对象或函数
  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
-->

<!--引入myModule文件-->
<script type="text/javascript" src="myModule2.js"></script>
<script type="text/javascript">
    myModule.doSomething1()
    myModule.doOtherthing2()
</script>
</body>

<!--我们在myModule2.js里直接把两个方法直接传递给window对象了。于是，在index.html中引入这个js文件后，会立即执行里面的匿名函数。在index.html中把myModule直接拿来用即可。-->
```

**总结：**

当然，方式一和方式二对比后，我们更建议采用方式二，因为很方便。

但无论如何，两种方式都采用了闭包。

# 闭包的缺点及解决

缺点：函数执行完后, 函数内的局部变量没有释放，占用内存时间会变长，容易造成内存泄露。


解决：能不用闭包就不用，及时释放。比如：

```javascript
f = null;  // 让内部函数成为垃圾对象 -->回收闭包
```

总而言之，你需要它，就是优点；你不需要它，就成了缺点。

# 内存溢出和内存泄露

## 内存溢出

**内存溢出**：一种程序运行出现的错误。当程序运行**需要的内存**超过了剩余的内存时, 就出抛出内存溢出的错误。

代码举例：

```javascript
var obj = {};
for (var i = 0; i < 10000; i++) {
    obj[i] = new Array(10000000);  //把所有的数组内容都放到obj里保存，导致obj占用了很大的内存空间
    console.log("-----");
}
```

## 内存泄漏

**内存泄漏**：**占用的内存**没有及时释放。

注意，内存泄露的次数积累多了，就容易导致内存溢出。

**常见的内存泄露**：

- 1.意外的全局变量

- 2.没有及时清理的计时器或回调函数

- 3.闭包

# ES6

-   ES6 之前的变量提升，会导致程序在运行时有一些不可预测性。而 ES6 中通过 `let`、`const` 变量优化了这一点。

-   ES6 增加了很多功能，比如：**常量、作用域、对象代理、异步处理、类、继承**等。这些在 ES5 中想实现，比较复杂，但是 ES6 对它们进行了封装。

-   ES6 之前的语法过于松散，实现相同的功能，不同的人可能会写出不同的代码。

**ES6 的目标是：让 JS 语言可以编写复杂的大型应用程序，成为企业级开发语言。**

# ES6 的变量声明（let、const、块级作用域）

ES5 中，使用 `var` 定义**全局变量**（ var 是 variable 的简写）。

ES6 中，新增了 let 和 const 来定义变量：

-   `let`：定义**局部变量**，替代 var。

-   `const`：定义**常量**（定义后，不可修改）。

## 1. var：定义全局变量

example1:

```js
{
    var a = 1;
}
console.log(a); //这里的 a，指的是 区块 里的 a
//上方代码是可以输出结果的，输出结果为 1。
//因为 var 是全局声明的，所以，即使是在区块里声明，但仍然在全局起作用。
```

**使用 var 声明的变量不具备块级作用域特性**。

example2:

```js
var a = 1;
{
    var a = 2;
}
console.log(a); //这里的 a，指的是 区块 里的 a
//上方代码的输出结果为 2 ，因为 var 是全局声明的。
```

**总结：**

用 var 定义的全部变量，有时候会污染整个 js 的作用域。我们在如今的实战中，基本都是用的 ES6 语法，所以请**尽量避免**使用 var 定义变量。

## 2. let：定义局部变量

example1：

```js
{
    let a = 'hello';
}
console.log(a); // 打印结果报错：Uncaught ReferenceError: a is not defined
//上方代码，打印报错。
```

example2：

```javascript
var a = 2;
{
    let a = 3;
}

console.log(a); // 打印结果：2
```

总结：**用 let 声明的变量，只在局部（块级作用域内）起作用**。

#### **经典面试题**：

let 可以防止数据污染，我们来看下面这个 **for 循环**的经典面试题。

1、用 var 声明变量：

```javascript
for (var i = 0; i < 10; i++) {
    console.log('循环体中:' + i);
}

console.log('循环体外:' + i);
```


上方代码可以正常打印结果，且最后一行的打印结果是 10。说明**循环体外**定义的变量 i，是**全局作用域**下的 i。

2、用 let 声明变量：

```javascript
for (let i = 0; i < 10; i++) {
    console.log('循环体中:' + i); // // 每循环一次，就会在 { } 所在的块级作用域中，重新定义一个新的变量 i
}

console.log('循环体外:' + i);
```

上方代码的关键在于：**每次循环都会产生一个块级作用域，每个块级作用域中会重新定义一个新的变量 i**。

另外，上方代码的最后一行无法打印结果，也就是说打印会报错。因为用 let 定义的变量 i，只在`{ }`这个**块级作用域**里生效。

**总结：**我们要习惯用 let 声明，减少 var 声明带来的**污染全局空间**。

为了进一步说明 let 不会带来污染，需要说明的是：当我们定义了`let a = 1`时，如果我们在同一个作用域内继续定义`let a = 2`，是会报错的。

## 3. const：定义常量

在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时可以用 const 来定义**常量**。常量就是值（内存地址）不能变化的量。

```javascript
const name = 'playlife'; //定义常量
```

用 const 声明的常量，只在局部（块级作用域内）起作用；而且，用 const 声明常量时，必须赋值，否则报错。

# let 和 const 的特点【重要】

-   不存在变量提升

-   禁止重复声明

-   支持块级作用域

-   暂时性死区 ：不支持同一作用域出现相同名字的变量


相反， 用`var`声明的变量：存在变量提升、可以重复声明、**没有块级作用域**。


# var、let、const 的共同点

-   全局作用域中定义的变量，可以在函数中使用。
-   函数中声明的变量，只能在函数及其子函数中使用，外部无法使用。

# var、let、const 的区别

1、var 声明的变量会挂载在 window 对象上，而 let 和 const 声明的变量不会

2、var 声明的变量存在变量提升，let 和 const 声明的变量不存在变量提升

3、var 声明不存在块级作用域，let 和 const 声明存在块级作用域

4、同一作用域下，var 可以重复声明变量，let 和 const 不能重复声明变量

5、let 和 const 的暂时性死区（DTC）

> 如果在当前块级作用域中使用了变量 ，并且当前块级作用域中通过 let/const 声明了这个变量，那么，**声明语句必须放在使用之前，也就是所谓的 DTC（暂时性死区）**。DTC 其实是一种保护机制，可以让我们养成良好的编程习惯。

6、const：一旦声明必须赋值；声明后不能再修改

# **const 常量到底能不能被修改？**

我们知道：用 const 声明的变量无法被修改。但还有一点，我们一定要记住：

-   如果用 const 声明基本数据类型，则无法被修改；

-   如果用 const 声明引用数据类型（即“对象”），这里的“无法被修改”指的是**不能改变内存地址的引用**；但对象里的内容是可以被修改的。

# 暂时性死区 DTC

ES6 规定：使用 let/const 声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。

也就是说，在使用 let/const 声明变量时，**变量需要先声明，再使用**（声明语句必须放在使用之前）。这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）。

DTC 其实是一种保护机制，可以让我们养成良好的编程习惯。

# ES6 变量的解构赋值 

## 数组的解构赋值

## 对象的解构赋值

## 字符串解构

# ES6函数扩展

# 箭头函数

## 箭头函数的 this 的指向

> 箭头函数只是为了让函数写起来更简洁优雅吗？当然不只是这个原因，还有一个很大的作用是与 this 的指向有关。

ES6 之前的普通函数中：this 指向的是函数被调用的对象（也就是说，谁调用了函数，this 就指向谁）。

而 ES6 的箭头函数中：**箭头函数本身不绑定 this**，this 指向的是**箭头函数定义位置的 this**（也就是说，箭头函数在哪个位置定义的，this 就跟这个位置的this指向相同）。

代码举例：

```js
const obj = { name: 'playlife' };
function fn1() {
    console.log(this); // 第一个 this
    return () => {
        console.log(this); // 第二个 this
    };
}

const fn2 = fn1.call(obj);//改变fn1的中的this指向obj
fn2();//打印结果说明 第一个this和第二个this指向一样
```

打印结果：

```
{name: "playlife"}
{name: "playlife"}
```

代码解释：

上面的代码中，箭头函数是在 fn1()函数里面定义的，所以第二个 this 跟 第一个 this 指向的是**同一个位置**。又因为，在执行 `fn1.call(obj)`之后，第一个 this 就指向了 obj，所以第二个 this 也是指向 了 obj。

## 面试题：箭头函数的this指向

代码举例：

```js
const name = 'playlfe';
const obj = {
    name: 'Johnny',
    sayHello: () => {
        console.log(this.name);
    },
};

obj.sayHello();//playlife
```

上方代码的打印结果是什么？你可能很难想到。

正确答案的打印结果是playlife。因为 `obj` 这个对象并不产生作用域， `sayHello()` 这个箭头函数实际仍然是定义在 window 当中的，所以 这里的 this指向是 window。

## 参数默认值

**传统写法**：

```javascript
function fn(param) {
    let p = param || 'playlife';
    console.log(p);
}
```

上方代码中，函数体内的写法是：如果 param 不存在，就用 `playlife`字符串做兜底。这样写比较啰嗦。

**ES6 写法**：（参数默认值的写法，很简洁）

```javascript
function fn(param = 'playlife') {
    console.log(param);
}
```

在 ES6 中定义方法时，我们可以给方法里的参数加一个**默认值**（缺省值）：

在 ES6 中定义方法时，我们可以给方法里的参数加一个**默认值**（缺省值）：

-   方法被调用时，如果没有给参数赋值，那就是用默认值；

-   方法被调用时，如果给参数赋值了新的值，那就用新的值。

如下：

```javascript
var fn2 = (a, b = 5) => {
    console.log('haha');
    return a + b;
};
console.log(fn2(1)); //第二个参数使用默认值 5。输出结果：6

console.log(fn2(1, 8)); //输出结果：9
```

**提醒 1**：默认值的后面，不能再有**没有默认值的变量**。比如`(a,b,c)`这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。

**提醒 2**：

我们来看下面这段代码：

```javascript
let x = 'playlife';
function fn(x, y = x) {
    console.log(x, y);
}
fn('Johnny');//Johnny Johnny
```

注意第二行代码，我们给 y 赋值为`x`，这里的`x`是括号里的第一个参数，并不是第一行代码里定义的`x`。打印结果：`Johnny Johnny`。

如果我把第一个参数改一下，改成：

```javascript
let x = 'playlife';
function fn(z, y = x) {
    console.log(z, y);
}
fn('Johnny');//Johnny playlife
```

此时打印结果是：`Johnny playlife`。

# ES6 :字符串、数组、对象的扩展

## 字符串的扩展

ES6中的字符串扩展，用得少，而且逻辑相对简单。如下：

- `includes(str)`：判断是否包含指定的字符串

- `startsWith(str)`：判断是否以指定字符串开头

- `endsWith(str)`：判断是否以指定字符串结尾

- `repeat(count)`：重复指定次数

## Number 的扩展

二进制与八进制数值表示法: 二进制用`0b`, 八进制用`0o`。

举例：

```javascript
console.log(0b1010);//10
console.log(0o56);//46
```

- `Number.isFinite(i)`：判断是否为有限大的数。比如`Infinity`这种无穷大的数，返回的就是false。

- `Number.isNaN(i)`：判断是否为NaN。

- `Number.isInteger(i)`：判断是否为整数。

- `Number.parseInt(str)`：将字符串转换为对应的数值。

- `Math.trunc(i)`：去除小数部分。

## 数组的扩展

### 扩展1：Array.from() 将伪数组转换为真数组

```js
Array.from(伪数组/可遍历的对象)//作用：将伪数组或可遍历对象转换为真数组。
```

### 扩展2：Array.of() 将一系列值转换成数组。

```js
Array.of(value1, value2, value3)//作用：将一系列值转换成数组。
```

### 扩展3：find() 和 findIndex()

#### **find():**


```javascript
	find(function(item, index, arr){return true})//作用：找出第一个满足「指定条件返回true」的元素。
```

#### **findIndex():**

```js
findIndex(function(item, index, arr){return true})//作用：找出第一个满足「指定条件返回true」的元素的index。
```

## 对象的扩展

#### 扩展1: Object.is() 判断两个数据是否完全相等


```javascript
Object.is(v1, v2)//作用：判断两个数据是否完全相等。底层是通过字符串来判断的。
```

我们先来看下面这两行代码的打印结果：


```javascript
console.log(0 == -0);//true
console.log(NaN == NaN);//false
```

上方代码中，第一行代码的打印结果为true，这个很好理解。第二行代码的打印结果为false，因为NaN和任何值都不相等。

```js
console.log(Object.is(0, -0));//false
console.log(Object.is(NaN, NaN));//true
//代码解释：还是刚刚说的那样，Object.is(v1, v2) 比较的是字符串是否相等。
```

#### 扩展2:Object.assign() 实战开发高频使用 重要

> Object.assign() 在实战开发中，使用到的频率非常高，一定要重视。

```js
Object.assign(目标对象, 源对象1, 源对象2...)
```

**作用：** 将源对象的属性追加到目标对象上。如果对象里属性名相同，会被覆盖。

其实可以理解成：将多个对象**合并**为一个新的对象。

**举例1**、对象的属性复制：

```javascript
let obj1 = { name: 'playlife', age: 23 };
let obj2 = { city: 'Shanghai' };
let obj3 = {};

Object.assign(obj3, obj1, obj2);
console.log(obj3);//{name: "playlife", age: 23, city: "Shanghai"}
//成功将obj1和obj2的属性复制（追加）给了obj3；如果属性名相同，会被覆盖。
```

**举例2**、将对象 A 赋值给对象B：

```js
const obj1 = { name: 'playlife', age: 23 };

const obj2 = Object.assign({}, obj1);
```

### 扩展3：`__proto__`属性

```js
let obj1 = { name: 'playlife' };
let obj2 = {};

obj2.__proto__ = obj1;

console.log(obj1);//{name: "playlife"}
console.log(obj2);
//{}
	//__proto__:
		//name: "playlife"
		//__proto__: Object
console.log(obj2.name);//playlife
//上方代码中，obj2本身是没有属性的，但是通过 __proto__ 属性和obj1产生关联，于是就可以获得obj1里的属性。
```

# ES6: Promise （异步编程）