# 21-30

## 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣

> Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

#### Object.prototype.toString.call()

每一个继承 Object 的对象都有 `toString` 方法，如果 `toString` 方法没有重写的话，会返回 `[Object type]`，其中 type 为对象的类型。

但当除了 Object 类型的对象外，其他类型直接使用 `toString` 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。

```js
const an = ['Hello','An'];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an); // "[object Array]"
```

这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

`Object.prototype.toString.call()` 常用于判断浏览器内置对象时。

### instanceof

`instanceof` 的内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型，找到返回 `true`，否则返回 `false`。

但 `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

#### Array.isArray()

功能：用来判断对象是否为数组

- instanceof 与 isArray

当检测Array实例时，`Array.isArray` 优于 `instanceof` ，因为 `Array.isArray` 可以检测出 `iframes`

- `Array.isArray()` 与 `Object.prototype.toString.call()`

`Array.isArray()`是ES5新增的方法，当不存在 `Array.isArray()` ，可以用 `Object.prototype.toString.call()` 实现。



就性能来说 Array.isArray 的性能最好，instanceof 比 toString.call 稍微好了一点点

补充：

typeof 不能校验 object 的其他类型，引用类型除了 function 都不能区分

instanceof 不能校验原始值类型

Object.prototype.toString.call() 不能校验自定义类型

## 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化





## 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景





## 聊聊 Redux 和 Vuex 的设计思想





## 说说浏览器和 Node 事件循环的区别

**浏览器:**



## 介绍模块化发展历程





## 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？



## cookie 和 token 都存放在 header 中，为什么不会劫持 token？



## 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的





## 两个数组合并成一个数组

> 请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']。

